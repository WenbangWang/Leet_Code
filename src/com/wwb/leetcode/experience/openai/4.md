https://www.1point3acres.com/bbs/thread-1152949-1-1.html

电面 coding：是给定root node，sendAsyncMessage()和receiveMessage()方法，让统计cluster中node的数量。地里面经里出现过的题目了。之后问了两个follow up，第一个问题是让返回cluster的结构而不是node的数量，第二个是问如果会message会fail，可能会有retry，怎么保证结果依然正确。第一个follow up我是用类似TreeNode的方法记录node之间的关系，最后return root node。第二个follow up是用set track已经访问过的节点，已经处理过的就不要再处理了。

电面SD1：slack，比较标准的题目。

coding这轮不错，这轮HR反馈是strong yes，但是SD没发挥好，所以被安排了一轮加面SD


电面SD2：CICD。其实比较偏向于job scheduler的内容。这次顺利通过

Onsite behavior：被问到了一个问题说你自己怎么衡量你6个月之后是否成功。啊，完全没想到这个问题，就现场想，说了一下希望做出一些有影响力的项目，成为组里的trusted partner，也希望可以帮到组里的人，包括当mentor。感觉答的有些混乱，不知道是不是这一轮被扣了分

Onsite SD：设计payment system。全程基本我在说，之后组里小哥问了一些细节，也都答出来，当时感觉还行

Onsite coding：KV store那道题。他们提供了一些接口，所以不用真正把数据写到file里。第一轮写过后，follow up是如果文件大小有限制怎么办，说了下思路说拆分成多个文件，同时maintain一个meta文件，说思路是对的，但是没时间写完code了

Onsite presentation：说项目，面试官非常engaging，中间提了很多问题来了解和跟上思路，结束时反馈还挺好的，面试官说good project

电面coding

class Node:
    def __init__(self, node_id: str, children: List[str], parent: str):
        self.node_id = node_id
        self.children = children if children else []
        self.parent = parent
        self.child_counts: Dict[str, int] = {}
        self.child_structures: Dict[str, str] = {}

    def receiveMessage(self, from_node_id: str, message: str):
        print(f"DEBUG: Node {self.node_id} received from {from_node_id}: '{message}'")

        if message == 'START_COUNT' and from_node_id is None:
            if not self.children:
                print(f"Final Result (Root {self.node_id}): Total nodes = 1")
            else:
                for child_id in self.children:
                    sendMessage(child_id, self.node_id, 'COUNT_REQUEST')
            return
        if message == 'COUNT_REQUEST' and from_node_id == self.parent:
            if not self.children:
                sendMessage(self.parent, self.node_id, 'COUNT_RESPONSE:1')
            else:
                for child_id in self.children:
                    sendMessage(child_id, self.node_id, 'COUNT_REQUEST')
            return
        if message.startswith('COUNT_RESPONSE:') and from_node_id in self.children:
            count = int(message.split(":")[1])
            self.child_counts[from_node_id] = count
            if len(self.child_counts) == len(self.children):
                total_count = 1 + sum(self.child_counts.values())
                if self.parent is None:
                    print(f"Final Result (Root {self.node_id}): Total nodes = {total_count}")
                else:
                    sendMessage(self.parent, self.node_id, f'COUNT_RESPONSE:{total_count}')
                self.child_counts.clear()
            return

        if message == 'START_STRUCTURE' and from_node_id is None:
            if not self.children:
                print(f"Final Result (Root {self.node_id}): Tree Structure = {self.node_id}")
            else:
                for child_id in self.children:
                    sendMessage(child_id, self.node_id, 'STRUCTURE_REQUEST')
            return

        if message == 'STRUCTURE_REQUEST' and from_node_id == self.parent:
            if not self.children:
                # 叶子节点的结构就是它自己
                sendMessage(self.parent, self.node_id, f'STRUCTURE_RESPONSE:{self.node_id}')
            else:
                for child_id in self.children:
                    sendMessage(child_id, self.node_id, 'STRUCTURE_REQUEST')
            return

        if message.startswith('STRUCTURE_RESPONSE:') and from_node_id in self.children:
            structure = message.split(':')[1]
            self.child_structures[from_node_id] = structure
            if len(self.child_structures) == len(self.children):
                sorted_child_ids = sorted(self.child_structures.keys())
                sub_structures = [self.child_structures[cid] for cid in sorted_child_ids]

                final_structures = f"{self.node_id}({','.join(sub_structures)})"
                if self.parent is None:
                    print(f"Final Result (Root {self.node_id}): Tree Structure = {final_structures}")
                else:
                    sendMessage(self.parent, self.node_id, f'STRUCTURE_RESPONSE:{final_structures}')
                self.child_structures.clear()
            return
